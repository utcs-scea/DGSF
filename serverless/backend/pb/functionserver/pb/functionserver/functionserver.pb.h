// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb/functionserver/functionserver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pb_2ffunctionserver_2ffunctionserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pb_2ffunctionserver_2ffunctionserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pb_2ffunctionserver_2ffunctionserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pb_2ffunctionserver_2ffunctionserver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pb_2ffunctionserver_2ffunctionserver_2eproto;
namespace functionserver {
class CreateReply;
struct CreateReplyDefaultTypeInternal;
extern CreateReplyDefaultTypeInternal _CreateReply_default_instance_;
class CreateRequest;
struct CreateRequestDefaultTypeInternal;
extern CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
class ReleaseRequest;
struct ReleaseRequestDefaultTypeInternal;
extern ReleaseRequestDefaultTypeInternal _ReleaseRequest_default_instance_;
}  // namespace functionserver
PROTOBUF_NAMESPACE_OPEN
template<> ::functionserver::CreateReply* Arena::CreateMaybeMessage<::functionserver::CreateReply>(Arena*);
template<> ::functionserver::CreateRequest* Arena::CreateMaybeMessage<::functionserver::CreateRequest>(Arena*);
template<> ::functionserver::ReleaseRequest* Arena::CreateMaybeMessage<::functionserver::ReleaseRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace functionserver {

// ===================================================================

class CreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:functionserver.CreateRequest) */ {
 public:
  inline CreateRequest() : CreateRequest(nullptr) {}
  ~CreateRequest() override;
  explicit constexpr CreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRequest(const CreateRequest& from);
  CreateRequest(CreateRequest&& from) noexcept
    : CreateRequest() {
    *this = ::std::move(from);
  }

  inline CreateRequest& operator=(const CreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRequest& operator=(CreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRequest*>(
               &_CreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateRequest& a, CreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRequest* New() const final {
    return new CreateRequest();
  }

  CreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "functionserver.CreateRequest";
  }
  protected:
  explicit CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKernelImagePathFieldNumber = 4,
    kKernelArgsFieldNumber = 5,
    kImageNameFieldNumber = 6,
    kImageStoragePrefixFieldNumber = 7,
    kInetDevFieldNumber = 8,
    kNameServerFieldNumber = 9,
    kAwsAccessKeyIDFieldNumber = 10,
    kAwsSecretAccessKeyFieldNumber = 11,
    kVmTypeFieldNumber = 16,
    kInitrdPathFieldNumber = 17,
    kCpuFieldNumber = 13,
    kMemFieldNumber = 14,
    kNumReplicaFieldNumber = 15,
  };
  // string kernelImagePath = 4;
  void clear_kernelimagepath();
  const std::string& kernelimagepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kernelimagepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kernelimagepath();
  PROTOBUF_MUST_USE_RESULT std::string* release_kernelimagepath();
  void set_allocated_kernelimagepath(std::string* kernelimagepath);
  private:
  const std::string& _internal_kernelimagepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernelimagepath(const std::string& value);
  std::string* _internal_mutable_kernelimagepath();
  public:

  // string kernelArgs = 5;
  void clear_kernelargs();
  const std::string& kernelargs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kernelargs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kernelargs();
  PROTOBUF_MUST_USE_RESULT std::string* release_kernelargs();
  void set_allocated_kernelargs(std::string* kernelargs);
  private:
  const std::string& _internal_kernelargs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kernelargs(const std::string& value);
  std::string* _internal_mutable_kernelargs();
  public:

  // string imageName = 6;
  void clear_imagename();
  const std::string& imagename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagename();
  PROTOBUF_MUST_USE_RESULT std::string* release_imagename();
  void set_allocated_imagename(std::string* imagename);
  private:
  const std::string& _internal_imagename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagename(const std::string& value);
  std::string* _internal_mutable_imagename();
  public:

  // string imageStoragePrefix = 7;
  void clear_imagestorageprefix();
  const std::string& imagestorageprefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_imagestorageprefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_imagestorageprefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_imagestorageprefix();
  void set_allocated_imagestorageprefix(std::string* imagestorageprefix);
  private:
  const std::string& _internal_imagestorageprefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imagestorageprefix(const std::string& value);
  std::string* _internal_mutable_imagestorageprefix();
  public:

  // string inetDev = 8;
  void clear_inetdev();
  const std::string& inetdev() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_inetdev(ArgT0&& arg0, ArgT... args);
  std::string* mutable_inetdev();
  PROTOBUF_MUST_USE_RESULT std::string* release_inetdev();
  void set_allocated_inetdev(std::string* inetdev);
  private:
  const std::string& _internal_inetdev() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_inetdev(const std::string& value);
  std::string* _internal_mutable_inetdev();
  public:

  // string nameServer = 9;
  void clear_nameserver();
  const std::string& nameserver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nameserver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nameserver();
  PROTOBUF_MUST_USE_RESULT std::string* release_nameserver();
  void set_allocated_nameserver(std::string* nameserver);
  private:
  const std::string& _internal_nameserver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nameserver(const std::string& value);
  std::string* _internal_mutable_nameserver();
  public:

  // string awsAccessKeyID = 10;
  void clear_awsaccesskeyid();
  const std::string& awsaccesskeyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_awsaccesskeyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_awsaccesskeyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_awsaccesskeyid();
  void set_allocated_awsaccesskeyid(std::string* awsaccesskeyid);
  private:
  const std::string& _internal_awsaccesskeyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_awsaccesskeyid(const std::string& value);
  std::string* _internal_mutable_awsaccesskeyid();
  public:

  // string awsSecretAccessKey = 11;
  void clear_awssecretaccesskey();
  const std::string& awssecretaccesskey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_awssecretaccesskey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_awssecretaccesskey();
  PROTOBUF_MUST_USE_RESULT std::string* release_awssecretaccesskey();
  void set_allocated_awssecretaccesskey(std::string* awssecretaccesskey);
  private:
  const std::string& _internal_awssecretaccesskey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_awssecretaccesskey(const std::string& value);
  std::string* _internal_mutable_awssecretaccesskey();
  public:

  // string vmType = 16;
  void clear_vmtype();
  const std::string& vmtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vmtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vmtype();
  PROTOBUF_MUST_USE_RESULT std::string* release_vmtype();
  void set_allocated_vmtype(std::string* vmtype);
  private:
  const std::string& _internal_vmtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vmtype(const std::string& value);
  std::string* _internal_mutable_vmtype();
  public:

  // string initrdPath = 17;
  void clear_initrdpath();
  const std::string& initrdpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initrdpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initrdpath();
  PROTOBUF_MUST_USE_RESULT std::string* release_initrdpath();
  void set_allocated_initrdpath(std::string* initrdpath);
  private:
  const std::string& _internal_initrdpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initrdpath(const std::string& value);
  std::string* _internal_mutable_initrdpath();
  public:

  // int64 cpu = 13;
  void clear_cpu();
  ::PROTOBUF_NAMESPACE_ID::int64 cpu() const;
  void set_cpu(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_cpu() const;
  void _internal_set_cpu(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 mem = 14;
  void clear_mem();
  ::PROTOBUF_NAMESPACE_ID::int64 mem() const;
  void set_mem(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_mem() const;
  void _internal_set_mem(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 numReplica = 15;
  void clear_numreplica();
  ::PROTOBUF_NAMESPACE_ID::uint32 numreplica() const;
  void set_numreplica(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_numreplica() const;
  void _internal_set_numreplica(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:functionserver.CreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernelimagepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kernelargs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagestorageprefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr inetdev_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nameserver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr awsaccesskeyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr awssecretaccesskey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vmtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initrdpath_;
  ::PROTOBUF_NAMESPACE_ID::int64 cpu_;
  ::PROTOBUF_NAMESPACE_ID::int64 mem_;
  ::PROTOBUF_NAMESPACE_ID::uint32 numreplica_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ffunctionserver_2ffunctionserver_2eproto;
};
// -------------------------------------------------------------------

class CreateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:functionserver.CreateReply) */ {
 public:
  inline CreateReply() : CreateReply(nullptr) {}
  ~CreateReply() override;
  explicit constexpr CreateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateReply(const CreateReply& from);
  CreateReply(CreateReply&& from) noexcept
    : CreateReply() {
    *this = ::std::move(from);
  }

  inline CreateReply& operator=(const CreateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateReply& operator=(CreateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateReply* internal_default_instance() {
    return reinterpret_cast<const CreateReply*>(
               &_CreateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateReply& a, CreateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateReply* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateReply* New() const final {
    return new CreateReply();
  }

  CreateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "functionserver.CreateReply";
  }
  protected:
  explicit CreateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kVmidFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string vmid = 2;
  void clear_vmid();
  const std::string& vmid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vmid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vmid();
  PROTOBUF_MUST_USE_RESULT std::string* release_vmid();
  void set_allocated_vmid(std::string* vmid);
  private:
  const std::string& _internal_vmid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vmid(const std::string& value);
  std::string* _internal_mutable_vmid();
  public:

  // @@protoc_insertion_point(class_scope:functionserver.CreateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vmid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ffunctionserver_2ffunctionserver_2eproto;
};
// -------------------------------------------------------------------

class ReleaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:functionserver.ReleaseRequest) */ {
 public:
  inline ReleaseRequest() : ReleaseRequest(nullptr) {}
  ~ReleaseRequest() override;
  explicit constexpr ReleaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseRequest(const ReleaseRequest& from);
  ReleaseRequest(ReleaseRequest&& from) noexcept
    : ReleaseRequest() {
    *this = ::std::move(from);
  }

  inline ReleaseRequest& operator=(const ReleaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseRequest& operator=(ReleaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseRequest* internal_default_instance() {
    return reinterpret_cast<const ReleaseRequest*>(
               &_ReleaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReleaseRequest& a, ReleaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReleaseRequest* New() const final {
    return new ReleaseRequest();
  }

  ReleaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReleaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReleaseRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "functionserver.ReleaseRequest";
  }
  protected:
  explicit ReleaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVmidFieldNumber = 1,
  };
  // string vmid = 1;
  void clear_vmid();
  const std::string& vmid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vmid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vmid();
  PROTOBUF_MUST_USE_RESULT std::string* release_vmid();
  void set_allocated_vmid(std::string* vmid);
  private:
  const std::string& _internal_vmid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vmid(const std::string& value);
  std::string* _internal_mutable_vmid();
  public:

  // @@protoc_insertion_point(class_scope:functionserver.ReleaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vmid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pb_2ffunctionserver_2ffunctionserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateRequest

// string kernelImagePath = 4;
inline void CreateRequest::clear_kernelimagepath() {
  kernelimagepath_.ClearToEmpty();
}
inline const std::string& CreateRequest::kernelimagepath() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.kernelImagePath)
  return _internal_kernelimagepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_kernelimagepath(ArgT0&& arg0, ArgT... args) {
 
 kernelimagepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.kernelImagePath)
}
inline std::string* CreateRequest::mutable_kernelimagepath() {
  std::string* _s = _internal_mutable_kernelimagepath();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.kernelImagePath)
  return _s;
}
inline const std::string& CreateRequest::_internal_kernelimagepath() const {
  return kernelimagepath_.Get();
}
inline void CreateRequest::_internal_set_kernelimagepath(const std::string& value) {
  
  kernelimagepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_kernelimagepath() {
  
  return kernelimagepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_kernelimagepath() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.kernelImagePath)
  return kernelimagepath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_kernelimagepath(std::string* kernelimagepath) {
  if (kernelimagepath != nullptr) {
    
  } else {
    
  }
  kernelimagepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kernelimagepath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.kernelImagePath)
}

// string kernelArgs = 5;
inline void CreateRequest::clear_kernelargs() {
  kernelargs_.ClearToEmpty();
}
inline const std::string& CreateRequest::kernelargs() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.kernelArgs)
  return _internal_kernelargs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_kernelargs(ArgT0&& arg0, ArgT... args) {
 
 kernelargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.kernelArgs)
}
inline std::string* CreateRequest::mutable_kernelargs() {
  std::string* _s = _internal_mutable_kernelargs();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.kernelArgs)
  return _s;
}
inline const std::string& CreateRequest::_internal_kernelargs() const {
  return kernelargs_.Get();
}
inline void CreateRequest::_internal_set_kernelargs(const std::string& value) {
  
  kernelargs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_kernelargs() {
  
  return kernelargs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_kernelargs() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.kernelArgs)
  return kernelargs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_kernelargs(std::string* kernelargs) {
  if (kernelargs != nullptr) {
    
  } else {
    
  }
  kernelargs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kernelargs,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.kernelArgs)
}

// string initrdPath = 17;
inline void CreateRequest::clear_initrdpath() {
  initrdpath_.ClearToEmpty();
}
inline const std::string& CreateRequest::initrdpath() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.initrdPath)
  return _internal_initrdpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_initrdpath(ArgT0&& arg0, ArgT... args) {
 
 initrdpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.initrdPath)
}
inline std::string* CreateRequest::mutable_initrdpath() {
  std::string* _s = _internal_mutable_initrdpath();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.initrdPath)
  return _s;
}
inline const std::string& CreateRequest::_internal_initrdpath() const {
  return initrdpath_.Get();
}
inline void CreateRequest::_internal_set_initrdpath(const std::string& value) {
  
  initrdpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_initrdpath() {
  
  return initrdpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_initrdpath() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.initrdPath)
  return initrdpath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_initrdpath(std::string* initrdpath) {
  if (initrdpath != nullptr) {
    
  } else {
    
  }
  initrdpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initrdpath,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.initrdPath)
}

// string imageName = 6;
inline void CreateRequest::clear_imagename() {
  imagename_.ClearToEmpty();
}
inline const std::string& CreateRequest::imagename() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.imageName)
  return _internal_imagename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_imagename(ArgT0&& arg0, ArgT... args) {
 
 imagename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.imageName)
}
inline std::string* CreateRequest::mutable_imagename() {
  std::string* _s = _internal_mutable_imagename();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.imageName)
  return _s;
}
inline const std::string& CreateRequest::_internal_imagename() const {
  return imagename_.Get();
}
inline void CreateRequest::_internal_set_imagename(const std::string& value) {
  
  imagename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_imagename() {
  
  return imagename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_imagename() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.imageName)
  return imagename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_imagename(std::string* imagename) {
  if (imagename != nullptr) {
    
  } else {
    
  }
  imagename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imagename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.imageName)
}

// string imageStoragePrefix = 7;
inline void CreateRequest::clear_imagestorageprefix() {
  imagestorageprefix_.ClearToEmpty();
}
inline const std::string& CreateRequest::imagestorageprefix() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.imageStoragePrefix)
  return _internal_imagestorageprefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_imagestorageprefix(ArgT0&& arg0, ArgT... args) {
 
 imagestorageprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.imageStoragePrefix)
}
inline std::string* CreateRequest::mutable_imagestorageprefix() {
  std::string* _s = _internal_mutable_imagestorageprefix();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.imageStoragePrefix)
  return _s;
}
inline const std::string& CreateRequest::_internal_imagestorageprefix() const {
  return imagestorageprefix_.Get();
}
inline void CreateRequest::_internal_set_imagestorageprefix(const std::string& value) {
  
  imagestorageprefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_imagestorageprefix() {
  
  return imagestorageprefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_imagestorageprefix() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.imageStoragePrefix)
  return imagestorageprefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_imagestorageprefix(std::string* imagestorageprefix) {
  if (imagestorageprefix != nullptr) {
    
  } else {
    
  }
  imagestorageprefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imagestorageprefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.imageStoragePrefix)
}

// string inetDev = 8;
inline void CreateRequest::clear_inetdev() {
  inetdev_.ClearToEmpty();
}
inline const std::string& CreateRequest::inetdev() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.inetDev)
  return _internal_inetdev();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_inetdev(ArgT0&& arg0, ArgT... args) {
 
 inetdev_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.inetDev)
}
inline std::string* CreateRequest::mutable_inetdev() {
  std::string* _s = _internal_mutable_inetdev();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.inetDev)
  return _s;
}
inline const std::string& CreateRequest::_internal_inetdev() const {
  return inetdev_.Get();
}
inline void CreateRequest::_internal_set_inetdev(const std::string& value) {
  
  inetdev_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_inetdev() {
  
  return inetdev_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_inetdev() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.inetDev)
  return inetdev_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_inetdev(std::string* inetdev) {
  if (inetdev != nullptr) {
    
  } else {
    
  }
  inetdev_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), inetdev,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.inetDev)
}

// string nameServer = 9;
inline void CreateRequest::clear_nameserver() {
  nameserver_.ClearToEmpty();
}
inline const std::string& CreateRequest::nameserver() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.nameServer)
  return _internal_nameserver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_nameserver(ArgT0&& arg0, ArgT... args) {
 
 nameserver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.nameServer)
}
inline std::string* CreateRequest::mutable_nameserver() {
  std::string* _s = _internal_mutable_nameserver();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.nameServer)
  return _s;
}
inline const std::string& CreateRequest::_internal_nameserver() const {
  return nameserver_.Get();
}
inline void CreateRequest::_internal_set_nameserver(const std::string& value) {
  
  nameserver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_nameserver() {
  
  return nameserver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_nameserver() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.nameServer)
  return nameserver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_nameserver(std::string* nameserver) {
  if (nameserver != nullptr) {
    
  } else {
    
  }
  nameserver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nameserver,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.nameServer)
}

// string awsAccessKeyID = 10;
inline void CreateRequest::clear_awsaccesskeyid() {
  awsaccesskeyid_.ClearToEmpty();
}
inline const std::string& CreateRequest::awsaccesskeyid() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.awsAccessKeyID)
  return _internal_awsaccesskeyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_awsaccesskeyid(ArgT0&& arg0, ArgT... args) {
 
 awsaccesskeyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.awsAccessKeyID)
}
inline std::string* CreateRequest::mutable_awsaccesskeyid() {
  std::string* _s = _internal_mutable_awsaccesskeyid();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.awsAccessKeyID)
  return _s;
}
inline const std::string& CreateRequest::_internal_awsaccesskeyid() const {
  return awsaccesskeyid_.Get();
}
inline void CreateRequest::_internal_set_awsaccesskeyid(const std::string& value) {
  
  awsaccesskeyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_awsaccesskeyid() {
  
  return awsaccesskeyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_awsaccesskeyid() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.awsAccessKeyID)
  return awsaccesskeyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_awsaccesskeyid(std::string* awsaccesskeyid) {
  if (awsaccesskeyid != nullptr) {
    
  } else {
    
  }
  awsaccesskeyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), awsaccesskeyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.awsAccessKeyID)
}

// string awsSecretAccessKey = 11;
inline void CreateRequest::clear_awssecretaccesskey() {
  awssecretaccesskey_.ClearToEmpty();
}
inline const std::string& CreateRequest::awssecretaccesskey() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.awsSecretAccessKey)
  return _internal_awssecretaccesskey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_awssecretaccesskey(ArgT0&& arg0, ArgT... args) {
 
 awssecretaccesskey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.awsSecretAccessKey)
}
inline std::string* CreateRequest::mutable_awssecretaccesskey() {
  std::string* _s = _internal_mutable_awssecretaccesskey();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.awsSecretAccessKey)
  return _s;
}
inline const std::string& CreateRequest::_internal_awssecretaccesskey() const {
  return awssecretaccesskey_.Get();
}
inline void CreateRequest::_internal_set_awssecretaccesskey(const std::string& value) {
  
  awssecretaccesskey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_awssecretaccesskey() {
  
  return awssecretaccesskey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_awssecretaccesskey() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.awsSecretAccessKey)
  return awssecretaccesskey_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_awssecretaccesskey(std::string* awssecretaccesskey) {
  if (awssecretaccesskey != nullptr) {
    
  } else {
    
  }
  awssecretaccesskey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), awssecretaccesskey,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.awsSecretAccessKey)
}

// int64 cpu = 13;
inline void CreateRequest::clear_cpu() {
  cpu_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRequest::_internal_cpu() const {
  return cpu_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRequest::cpu() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.cpu)
  return _internal_cpu();
}
inline void CreateRequest::_internal_set_cpu(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  cpu_ = value;
}
inline void CreateRequest::set_cpu(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.cpu)
}

// int64 mem = 14;
inline void CreateRequest::clear_mem() {
  mem_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRequest::_internal_mem() const {
  return mem_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRequest::mem() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.mem)
  return _internal_mem();
}
inline void CreateRequest::_internal_set_mem(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  mem_ = value;
}
inline void CreateRequest::set_mem(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_mem(value);
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.mem)
}

// uint32 numReplica = 15;
inline void CreateRequest::clear_numreplica() {
  numreplica_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRequest::_internal_numreplica() const {
  return numreplica_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CreateRequest::numreplica() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.numReplica)
  return _internal_numreplica();
}
inline void CreateRequest::_internal_set_numreplica(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  numreplica_ = value;
}
inline void CreateRequest::set_numreplica(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_numreplica(value);
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.numReplica)
}

// string vmType = 16;
inline void CreateRequest::clear_vmtype() {
  vmtype_.ClearToEmpty();
}
inline const std::string& CreateRequest::vmtype() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateRequest.vmType)
  return _internal_vmtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRequest::set_vmtype(ArgT0&& arg0, ArgT... args) {
 
 vmtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateRequest.vmType)
}
inline std::string* CreateRequest::mutable_vmtype() {
  std::string* _s = _internal_mutable_vmtype();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateRequest.vmType)
  return _s;
}
inline const std::string& CreateRequest::_internal_vmtype() const {
  return vmtype_.Get();
}
inline void CreateRequest::_internal_set_vmtype(const std::string& value) {
  
  vmtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRequest::_internal_mutable_vmtype() {
  
  return vmtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRequest::release_vmtype() {
  // @@protoc_insertion_point(field_release:functionserver.CreateRequest.vmType)
  return vmtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRequest::set_allocated_vmtype(std::string* vmtype) {
  if (vmtype != nullptr) {
    
  } else {
    
  }
  vmtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vmtype,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateRequest.vmType)
}

// -------------------------------------------------------------------

// CreateReply

// string ip = 1;
inline void CreateReply::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& CreateReply::ip() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateReply.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateReply::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateReply.ip)
}
inline std::string* CreateReply::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateReply.ip)
  return _s;
}
inline const std::string& CreateReply::_internal_ip() const {
  return ip_.Get();
}
inline void CreateReply::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateReply::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateReply::release_ip() {
  // @@protoc_insertion_point(field_release:functionserver.CreateReply.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateReply::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateReply.ip)
}

// string vmid = 2;
inline void CreateReply::clear_vmid() {
  vmid_.ClearToEmpty();
}
inline const std::string& CreateReply::vmid() const {
  // @@protoc_insertion_point(field_get:functionserver.CreateReply.vmid)
  return _internal_vmid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateReply::set_vmid(ArgT0&& arg0, ArgT... args) {
 
 vmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.CreateReply.vmid)
}
inline std::string* CreateReply::mutable_vmid() {
  std::string* _s = _internal_mutable_vmid();
  // @@protoc_insertion_point(field_mutable:functionserver.CreateReply.vmid)
  return _s;
}
inline const std::string& CreateReply::_internal_vmid() const {
  return vmid_.Get();
}
inline void CreateReply::_internal_set_vmid(const std::string& value) {
  
  vmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateReply::_internal_mutable_vmid() {
  
  return vmid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateReply::release_vmid() {
  // @@protoc_insertion_point(field_release:functionserver.CreateReply.vmid)
  return vmid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateReply::set_allocated_vmid(std::string* vmid) {
  if (vmid != nullptr) {
    
  } else {
    
  }
  vmid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vmid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.CreateReply.vmid)
}

// -------------------------------------------------------------------

// ReleaseRequest

// string vmid = 1;
inline void ReleaseRequest::clear_vmid() {
  vmid_.ClearToEmpty();
}
inline const std::string& ReleaseRequest::vmid() const {
  // @@protoc_insertion_point(field_get:functionserver.ReleaseRequest.vmid)
  return _internal_vmid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReleaseRequest::set_vmid(ArgT0&& arg0, ArgT... args) {
 
 vmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:functionserver.ReleaseRequest.vmid)
}
inline std::string* ReleaseRequest::mutable_vmid() {
  std::string* _s = _internal_mutable_vmid();
  // @@protoc_insertion_point(field_mutable:functionserver.ReleaseRequest.vmid)
  return _s;
}
inline const std::string& ReleaseRequest::_internal_vmid() const {
  return vmid_.Get();
}
inline void ReleaseRequest::_internal_set_vmid(const std::string& value) {
  
  vmid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReleaseRequest::_internal_mutable_vmid() {
  
  return vmid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReleaseRequest::release_vmid() {
  // @@protoc_insertion_point(field_release:functionserver.ReleaseRequest.vmid)
  return vmid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReleaseRequest::set_allocated_vmid(std::string* vmid) {
  if (vmid != nullptr) {
    
  } else {
    
  }
  vmid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vmid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:functionserver.ReleaseRequest.vmid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace functionserver

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pb_2ffunctionserver_2ffunctionserver_2eproto
